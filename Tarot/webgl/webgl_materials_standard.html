<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - materials - standard</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
    <div id="info">
        <a href="http://filmicworlds.com/blog/filmic-tonemapping-with-piecewise-power-curves/"
           target="_blank" rel="noopener">Filmic Tonemapping</a>
    </div>

    <script type="module">

        import * as THREE from '../build/three.module.js';

        import Stats from './jsm/libs/stats.module.js';

        import { GUI } from './jsm/libs/dat.gui.module.js';
        import { TrackballControls } from './jsm/controls/TrackballControls.js';
        import { OrbitControls } from './jsm/controls/OrbitControls.js';
        import { OBJLoader } from './jsm/loaders/OBJLoader.js';
        import { RGBELoader } from './jsm/loaders/RGBELoader.js';
        import { MTLLoader } from './jsm/loaders/MTLLoader.js';


        const statsEnabled = true;

        let container, stats, group;

        let camera, renderer, scene
        

        init();
        animate();
        render();
        loadPolyhedron();
        removeEntity();
        wait();


        

        function init() {

            group = new THREE.Object3D();
            scene = new THREE.Scene();

            container = document.createElement('div');
            document.body.appendChild(container);

            //

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 20);
            camera.position.set(- 1.8, 0.6, 2.7);

            //

            //scene.add( new THREE.HemisphereLight( 0x443333, 0x222233, 4 ) );

            //

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            renderer.outputEncoding = THREE.sRGBEncoding;
            //renderer.toneMapping = THREE.ReinhardToneMapping;
            //renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMapping = THREE.CineonToneMapping;

            renderer.toneMappingExposure = 1;


            const environments = {

                'quarry_01_1k': {
                    filename: 'quarry_01_1k.hdr'
                },
                'royal_esplanade_1k': {
                    filename: 'royal_esplanade_1k.hdr'
                },
                'the_lost_city_4k': {
                    filename: 'the_lost_city_4k.hdr'
                },
                'Rooitou park_4k': {
                    filename: 'rooitou_park_4k.hdr'
                },
                'Overpass_1k': {
                    filename: 'pedestrian_overpass_1k.hdr'
                },
                'venice_sunset_1k': {
                    filename: 'venice_sunset_1k.hdr'
                }

            };

            const objects_3D = {

                'ObtuseGoldenRhombohedron': {
                    filename: 'ObtuseGoldenRhombohedron.mtl'
                   
                },
                'AcuteGoldenRhombohedron': {
                    filename: 'AcuteGoldenRhombohedron.mtl'
                   
                },
                'BilinskiDodecahedron': {
                    filename: 'BilinskiDodecahedron.mtl'
                   
                },
                'RhombicIcosahedron': {
                    filename: 'RhombicIcosahedron.mtl'
                   
                },
                'RhombicTriacontahedron': {
                    filename: 'RhombicTriacontahedron.mtl'
                   
                },
                'DisdyakisTriacontahedron': {
                    filename: 'DisdyakisTriacontahedron.mtl'
                   
                },

                 //Platonics
                'Tetrahedron': {
                    filename: 'Tetrahedron.mtl'
                    
                },
                'Cube': {
                    filename: 'Cube.mtl'
                    
                },
                'Octahedron': {
                    filename: 'Octahedron.mtl'
                    
                },
                'Dodecahedron': {
                    filename: 'Dodecahedron.mtl'
                    
                },
                'Icosahedron': {
                    filename: 'Icosahedron.mtl'
                   
                }

            };

            

            function loadEnvironment( name ) {

                if (environments[name].texture !== undefined) {

                    scene.background = environments[name].texture;
                    scene.environment = environments[name].texture;
                    return;
                }

                const filename = environments[name].filename;
                new RGBELoader()
                    .setDataType(THREE.UnsignedByteType)
                    .setPath('textures/equirectangular/')
                    .load(filename, function ( hdrEquirect ) {

                        const envMap1 = pmremGenerator.fromEquirectangular( hdrEquirect ).texture;
                        const envMap2 = new THREE.WebGLCubeRenderTarget(4096).fromEquirectangularTexture(renderer, hdrEquirect);
                        hdrEquirect.dispose();

                        scene.background = envMap2;
                        scene.environment = envMap1;

                        pmremGenerator.dispose();

                        environments[name].texture = envMap1.texture;

                    });

            }


            const manager = new THREE.LoadingManager();
            let objloader = new OBJLoader(manager)

            const material = new THREE.MeshStandardMaterial();

            function loadPolyhedron(name) {

           

             new MTLLoader(manager)
                    .setPath('models/Wavefront/'+ name +'/')
                    .load( name );

             const loader = new THREE.TextureLoader()
                    .setPath('models/Wavefront/'+ name +'/')

                //roughness is in G channel, metalness is in B channel
                material.metalnessMap = material.roughnessMap = loader.load('metallicTexture&wood_Wood_006_Roughness_3.jpg');
                material.normalMap = loader.load('wood_Wood_006_NormalMap.jpg');

                const diffuseMap = loader.load('wood_Wood_006_Color.jpg');
                diffuseMap.encoding = THREE.sRGBEncoding;
                material.map = diffuseMap;

   
                objloader.setPath('models/Wavefront/' + name + '/')
                    .load(''+ name +'.Wavefront', function (obj) {

                        obj.scale.multiplyScalar(1.5);

                        obj.traverse(function (child) {

                            if (child.isMesh) {

                                
                                child.material = material;

                            }

                        });

                        group.add(obj);
                       
                    });

                scene.add(group);
            }


            const params = {

                scene: Object.keys(environments)[0],
                polyhedron: Object.keys(objects_3D)[0]

            };

            /////

            loadEnvironment(params.scene);

            loadPolyhedron(params.polyhedron);
            scene.add(group);
            

            ////
            

            //const gui = new GUI();
            const  gui = new GUI({ width: 330 });

            gui.add(params, 'scene', Object.keys(environments)).onChange(function (value) {

              
                loadEnvironment(value);

            });


            gui.add(params, 'polyhedron', Object.keys(objects_3D)).onChange(function (value) {


                for (var i = group.children.length - 1; i >= 0; i--) {
                    group.remove(group.children[i]);
                }

                loadPolyhedron(value);
                //group.add(value);
                //scene.add(group);
               
               // render();
            });


            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();

            gui.open();

            //

            if (statsEnabled) {

                stats = new Stats();
                container.appendChild(stats.dom);

            }

            //controls = new TrackballControls( camera, renderer.domElement );
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.addEventListener('change', render); // use if there is no animation loop
            controls.minDistance = 2;
            controls.maxDistance = 10;
            controls.target.set(0, 0, - 0.2);
            controls.update();
            

            window.addEventListener('resize', onWindowResize);

        }

        function removeEntity(name) {
           
            const selectedObject = scene.getObjectByName(name);
          
            scene.remove(selectedObject); 
           
        };			

        //

        function wait(ms) {
            var start = new Date().getTime();
            var end = start;
            while (end < start + ms) {
                end = new Date().getTime();
            }
        }

        function onWindowResize() {

            renderer.setSize(window.innerWidth, window.innerHeight);

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            render();
        }

        //

        function animate() {

            requestAnimationFrame(animate);
            if (statsEnabled) stats.update();

             //controls.update(); //trackball
            render();
           
        }

        function render() {

            renderer.render(scene, camera);
        }

    </script>

</body>
</html>
